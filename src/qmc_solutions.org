#+TITLE: QMC-LTTC 2023 Exercises
#+AUTHOR: Vijay Gopal Chilkuri
#+LANGUAGE:  en
#+INFOJS_OPT: toc:t mouse:underline path:org-info.js
#+STARTUP: latexpreview
#+LATEX_CLASS: article
#+LATEX_HEADER_EXTRA: \usepackage{minted}
#+HTML_HEAD: <link rel="stylesheet" title="Standard" href="worg.css" type="text/css" />

#+OPTIONS: H:4 num:t toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS: TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
# EXCLUDE_TAGS: solution solution2 noexport
# EXCLUDE_TAGS: solution noexport
#+EXCLUDE_TAGS: noexport

  #+BEGIN_SRC elisp :output none :exports none
(setq org-latex-listings 'minted
      org-latex-packages-alist '(("" "minted"))
      org-latex-pdf-process
      '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
(setq org-latex-minted-options '(("breaklines" "true")
                                 ("breakanywhere" "true")))
(setq org-latex-minted-options
      '(("frame" "lines")
        ("fontsize" "\\scriptsize")
        ("linenos" "")))
(org-beamer-export-to-pdf)

  #+END_SRC

  #+RESULTS:
  : /home/chilkuri/Documents/codes/julia/qmc-lttc-2023/qmc_solutions.pdf



* Numerical evaluation of the energy of the hydrogen atom

** Local energy
   :PROPERTIES:
   :header-args:julia: :tangle hydrogen.jl
   :END:

*** Exercise 1

    #+begin_exercise
    Write a function which computes the potential at $\mathbf{r}$.
    The function accepts a 3-dimensional vector =r= as input argument
    and returns the potential.
    #+end_exercise

    $\mathbf{r}=\left( \begin{array}{c} x \\ y\\ z\end{array} \right)$, so
    $$
    V(\mathbf{r}) = -\frac{1}{\sqrt{x^2 + y^2 + z^2}}
    $$


**** Solution                                                      :solution:
    *Julia*
     #+BEGIN_SRC julia :results none
using LinearAlgebra

function potential(r)
    nr = norm(r);
    @assert (nr > 0.0);
    return(-1.0/nr)
end
     #+END_SRC

*** Exercise 2
    #+begin_exercise
    Write a function which computes the wave function at $\mathbf{r}$.
    The function accepts a scalar =a= and a 3-dimensional vector =r= as
    input arguments, and returns a scalar.
    #+end_exercise

**** Solution                                                      :solution:
    *Julia*
     #+BEGIN_SRC julia :results none
function psi(a, r)
    return exp(-a*norm(r))
end
     #+END_SRC
*** Exercise 3
    #+begin_exercise
    Write a function which computes the local kinetic energy at $\mathbf{r}$.
    The function accepts =a= and =r= as input arguments and returns the
    local kinetic energy.
    #+end_exercise

    The local kinetic energy is defined as $$T_L(\mathbf{r}) = -\frac{1}{2}\frac{\Delta \Psi(\mathbf{r})}{\Psi(\mathbf{r})}.$$

    We differentiate $\Psi$ with respect to $x$:

    \[ \Psi(\mathbf{r})  =  \exp(-a\,|\mathbf{r}|) \]
    \[\frac{\partial \Psi}{\partial x}
      = \frac{\partial \Psi}{\partial |\mathbf{r}|} \frac{\partial |\mathbf{r}|}{\partial x}
      =  - \frac{a\,x}{|\mathbf{r}|} \Psi(\mathbf{r}) \]

    and we differentiate a second time:

    $$
    \frac{\partial^2 \Psi}{\partial x^2} =
    \left( \frac{a^2\,x^2}{|\mathbf{r}|^2}  -
    \frac{a(y^2+z^2)}{|\mathbf{r}|^{3}} \right) \Psi(\mathbf{r}).
    $$

    The Laplacian operator $\Delta = \frac{\partial^2}{\partial x^2} +
    \frac{\partial^2}{\partial y^2} + \frac{\partial^2}{\partial z^2}$
    applied to the wave function gives:

    $$
    \Delta \Psi (\mathbf{r}) = \left(a^2 - \frac{2a}{\mathbf{|r|}} \right) \Psi(\mathbf{r})\,.
    $$

    Therefore, the local kinetic energy is
    $$
    T_L (\mathbf{r}) = -\frac{1}{2}\left(a^2 - \frac{2a}{\mathbf{|r|}} \right)
    $$

    *Julia*
     #+BEGIN_SRC julia :results none
function kinetic(a,r)
    nr = norm(r);
    @assert (nr > 0.0);
    return(-0.5 * (a*a - 2.0*a/nr))
end
     #+END_SRC

*** Exercise 4
    #+begin_exercise
    Write a function which computes the local energy at $\mathbf{r}$,
    using the previously defined functions.
    The function accepts =a= and =r= as input arguments and returns the
    local kinetic energy.
    #+end_exercise

    $$
    E_L(\mathbf{r}) = -\frac{1}{2} \frac{\Delta \Psi}{\Psi} (\mathbf{r}) + V(\mathbf{r})
    $$


    *Julia*
     #+BEGIN_SRC julia :results none
function e_loc(a,r)
    epot = potential(r);
    ekin = kinetic(a,r);
    return( ekin + epot )
end
     #+END_SRC

** Plot of the local energy along the $x$ axis
   :PROPERTIES:
   :header-args:julia: :tangle plot_hydrogen.jl
   :END:

*** Exercise

    #+begin_exercise
    For multiple values of $a$ (0.1, 0.2, 0.5, 1., 1.5, 2.), plot the
    local energy along the $x$ axis. In Python, you can use matplotlib
    for example. In Fortran, it is convenient to write in a text file
    the values of $x$ and $E_L(\mathbf{r})$ for each point, and use
    Gnuplot to plot the files. With Gnuplot, you will need 2 blank
    lines to separate the data corresponding to different values of $a$.
    #+end_exercise

   #+begin_note
   The potential and the kinetic energy both diverge at $r=0$, so we
   choose a grid which does not contain the origin to avoid numerical issues.
   #+end_note

**** Solution                                                      :solution:
    *Julia*
     #+BEGIN_SRC julia :results none
using LinearAlgebra
using Plots

include("hydrogen.jl")

x=range(-5,5,length=100)
y=x .|> y->e_loc(0.1,y)
plt = plot(x,y,label="a=0.1")

for a in [0.2, 0.5, 1., 1.5, 2.]
  y=x .|> y->e_loc(a,y)
  plot!(x,y,label="a=$(a)");
end

savefig(plt, "plot_py.png")
     #+end_src
** Numerical estimation of the energy
   :PROPERTIES:
   :header-args:julia: :tangle energy_hydrogen.jl
   :END:

*** Exercise
     #+begin_exercise
    Compute a numerical estimate of the energy using a grid of
    $50\times50\times50$ points in the range $(-5,-5,-5) \le
    \mathbf{r} \le (5,5,5)$.
     #+end_exercise
**** Solution                                                      :solution:
    *Julia*
     #+BEGIN_SRC julia :results output :exports both
using LinearAlgebra
include("hydrogen.jl");


interval = range(-5,5,length=50);
delta = (interval[2]-interval[1])^3;

r = [0.,0.,0.];
for a in [0.1, 0.2, 0.5, 0.9, 1., 1.5, 2.]
    E    = 0.;
    norm = 0.;

    for x in interval
        r[1] = x;
        for y in interval
            r[2] = y;
            for z in interval
                r[3] = z;

                w = psi(a,r);
                w = w * w * delta;

                E    += w * e_loc(a,r);
                norm += w;
            end
        end
    end
    E = E / norm;
    println("a = $(a) \t E = $(E)")
end
     #+end_src

     #+RESULTS:
     : a = 0.1 	 E = -0.24518438948809218
     : a = 0.2 	 E = -0.26966057967803525
     : a = 0.5 	 E = -0.3856357612517401
     : a = 0.9 	 E = -0.49435709786716214
     : a = 1.0 	 E = -0.5
     : a = 1.5 	 E = -0.3924296708260237
     : a = 2.0 	 E = -0.08086980667845059

*** Exercise
   #+begin_exercise
   Add the calculation of the variance to the previous code, and
   compute a numerical estimate of the variance of the local energy using
   a grid of $50\times50\times50$ points in the range $(-5,-5,-5) \le
   \mathbf{r} \le (5,5,5)$ for different values of $a$.

   #+end_exercise
     *Julia*
     #+BEGIN_SRC julia :results output :exports both
using LinearAlgebra
include("hydrogen.jl");


interval = range(-5,5,length=50);
delta = (interval[2]-interval[1])^3;

r = [0.,0.,0.];

for a in [0.1, 0.2, 0.5, 0.9, 1., 1.5, 2.]
    E    = 0.;
    E2   = 0.;
    norm = 0.;

    for x in interval
        r[1] = x;
        for y in interval
            r[2] = y;
            for z in interval
                r[3] = z;

                w = psi(a,r);
                w = w * w * delta;

                E    += w * e_loc(a,r);
                E2   += w * e_loc(a,r) * e_loc(a,r);
                norm += w;
            end
        end
    end
    E = E / norm;
    E2= E2/ norm;
    var = E2 - E*E;
    println("a = $(a) \t E = $(E) \t σ^2 = $(var)")
end
     #+end_src

     #+RESULTS:
     : a = 0.1 	 E = -0.24518438948809218 	 σ^2 = 0.026965218719722663
     : a = 0.2 	 E = -0.26966057967803525 	 σ^2 = 0.037197072370200784
     : a = 0.5 	 E = -0.3856357612517401 	 σ^2 = 0.053185967578480015
     : a = 0.9 	 E = -0.49435709786716214 	 σ^2 = 0.005778118170656099
     : a = 1.0 	 E = -0.5 	 σ^2 = 0.0
     : a = 1.5 	 E = -0.3924296708260237 	 σ^2 = 0.3144967090917285
     : a = 2.0 	 E = -0.08086980667845059 	 σ^2 = 1.806881427084649

* Variational Monte Carlo
** Computation of the statistical error
   :PROPERTIES:
   :header-args:julia: :tangle qmc_stats.jl
   :END:

   To compute the statistical error, you need to perform $M$
   independent Monte Carlo calculations. You will obtain $M$ different
   estimates of the energy, which are expected to have a Gaussian
   distribution for large $M$, according to the [[https://en.wikipedia.org/wiki/Central_limit_theorem][Central Limit Theorem]].

   The estimate of the energy is

   $$
   E = \frac{1}{M} \sum_{i=1}^M E_i
   $$

   The variance of the average energies can be computed as

   $$
   \sigma^2 = \frac{1}{M-1} \sum_{i=1}^{M} (E_i - E)^2
   $$

   And the confidence interval is given by

   $$
   E \pm \delta E, \text{ where } \delta E = \frac{\sigma}{\sqrt{M}}
   $$
*** Exercise
   #+begin_exercise
   Write a function returning the average and statistical error of an
   input array.
   #+end_exercise
**** Solution                                                     :solution:
    *Julia*
     #+BEGIN_SRC julia :results none :exports code

function ave_error(arr)
    M = length(arr)
    @assert(M>0)

    if M == 1
        average = arr[1]
        error   = 0.

    else
        average = sum(arr)/M
        variance = 1.0/(M-1) * ( arr |> x-> ( x .- average ).^2 |> sum )
        error = sqrt(variance/M)
    end

    return (average, error)
end
     #+END_SRC

** Uniform sampling in the box
   :PROPERTIES:
   :header-args:julia: :tangle qmc_uniform.jl
   :END:

*** Exercise

   One Monte Carlo run will consist of $N_{\rm MC}$ Monte Carlo iterations. At every Monte Carlo iteration:

   - Draw a random point $\mathbf{r}_i$ in the box $(-5,-5,-5) \le
     (x,y,z) \le (5,5,5)$
   - Compute $|\Psi(\mathbf{r}_i)|^2$ and accumulate the result in a
     variable =normalization=
   - Compute $|\Psi(\mathbf{r}_i)|^2 \times E_L(\mathbf{r}_i)$, and accumulate the
     result in a variable =energy=

   Once all the iterations have been computed, the run returns the average energy
   $\bar{E}_k$ over the $N_{\rm MC}$ iterations of the run.

   To compute the statistical error, perform $M$ independent runs. The
   final estimate of the energy will be the average over the
   $\bar{E}_k$, and the variance of the $\bar{E}_k$ will be used to
   compute the statistical error.

    #+begin_exercise
    Parameterize the wave function with $a=1.2$.  Perform 30
    independent Monte Carlo runs ($M$), each with 100 000 Monte Carlo
    steps ($N_{MC}$). Store the final energies of each run and use this array to
    compute the average energy and the associated error bar ($\delta E$).

    #+end_exercise
**** Solution                                                     :solution:
    *Julia*
     #+BEGIN_SRC julia  :results output :exports both
include("hydrogen.jl");
include("qmc_stats.jl");

function MonteCarlo(a, nmax)
     energy = 0.;
     normalization = 0.;

     for istep in range(1,nmax)

         R = 5.0;
         phi = rand()*2*π;
         costheta = rand()*2 - 1.0;
         u = rand();

         theta = acos( costheta );
         r = R * cbrt( u );

         # Spherical distribution
         x = r * sin( theta) * cos( phi );
         y = r * sin( theta) * sin( phi );
         z = r * cos( theta );
         # Cuboidal distribution
         #x = 10 * rand() - 5.0;
         #y = 10 * rand() - 5.0;
         #z = 10 * rand() - 5.0;
         r = [x,y,z];

         w = psi(a,r);
         w = w*w;

         energy        += w * e_loc(a,r);
         normalization += w;
     end

     return energy / normalization
end

a    = 1.2;
nmax = 100_000;

X = [MonteCarlo(a,nmax) for i in range(1,30)];
E, deltaE = ave_error(X);

println("E = $(E) +/- $(deltaE)")
     #+END_SRC

     #+RESULTS:
     : Sphere
     : E = -0.48024356420973185 +/- 0.001321161390324179
     : Cube
     : E = -0.4787870280458861 +/- 0.0020675933699247735
